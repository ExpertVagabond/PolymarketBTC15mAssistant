<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PolySignal API Docs</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: #0b0b11; color: #c8c8d0; min-height: 100vh; line-height: 1.5; }

    .header { padding: 14px 28px; background: #101018; border-bottom: 1px solid #1e1e2a; display: flex; align-items: center; justify-content: space-between; }
    .header-left { display: flex; align-items: center; gap: 14px; }
    .header-left h1 { font-size: 17px; color: #fff; font-weight: 700; }
    .header-left .badge { font-size: 10px; font-weight: 700; padding: 2px 10px; border-radius: 20px; background: #3b82f620; color: #60a5fa; }
    .header-right { display: flex; align-items: center; gap: 14px; }
    .header-link { color: #6b7280; text-decoration: none; font-size: 12px; font-weight: 500; }
    .header-link:hover { color: #a5b4fc; }

    .hero { text-align: center; padding: 40px 28px 20px; }
    .hero h2 { font-size: 22px; color: #fff; font-weight: 700; margin-bottom: 6px; }
    .hero p { font-size: 13px; color: #6b7280; max-width: 550px; margin: 0 auto; }

    .docs-wrap { max-width: 800px; margin: 0 auto; padding: 0 28px 40px; }

    .info-box { background: #12121a; border: 1px solid #1e1e2a; border-radius: 10px; padding: 16px 18px; margin-bottom: 20px; font-size: 12px; color: #9ca3af; line-height: 1.7; }
    .info-box code { background: #1a1a24; padding: 2px 6px; border-radius: 4px; font-family: monospace; color: #a5b4fc; font-size: 11px; }

    .section-title { font-size: 14px; font-weight: 700; color: #e5e7eb; margin: 28px 0 12px; padding-bottom: 6px; border-bottom: 1px solid #1e1e2a; }

    .endpoint { background: #12121a; border: 1px solid #1e1e2a; border-radius: 10px; padding: 14px 18px; margin-bottom: 10px; }
    .ep-header { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
    .ep-method { font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 4px; text-transform: uppercase; }
    .ep-method.get { background: #34d39920; color: #34d399; }
    .ep-method.post { background: #3b82f620; color: #60a5fa; }
    .ep-method.delete { background: #f8717120; color: #f87171; }
    .ep-path { font-family: monospace; font-size: 13px; color: #e5e7eb; font-weight: 500; }
    .ep-desc { font-size: 12px; color: #6b7280; margin-bottom: 8px; }
    .ep-actions { display: flex; gap: 6px; }
    .try-btn { background: #1a1a24; border: 1px solid #2a2a36; border-radius: 6px; padding: 4px 12px; font-size: 10px; color: #93c5fd; cursor: pointer; font-family: inherit; font-weight: 600; transition: all 0.15s; }
    .try-btn:hover { border-color: #3b82f6; background: #3b82f618; }
    .ep-response { margin-top: 8px; background: #0e0e16; border: 1px solid #141420; border-radius: 6px; padding: 10px 14px; font-family: monospace; font-size: 11px; color: #9ca3af; max-height: 300px; overflow: auto; white-space: pre-wrap; word-break: break-all; display: none; }

    .footer { text-align: center; padding: 28px; color: #27272f; font-size: 11px; }
    .footer a { color: #4b5563; }

    @media (max-width: 768px) { .docs-wrap { padding: 0 16px 28px; } }
  </style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <h1>PolySignal</h1>
    <span class="badge">API DOCS</span>
  </div>
  <div class="header-right">
    <a href="/" class="header-link">Dashboard</a>
    <a href="/stats.html" class="header-link">Performance</a>
    <a href="/leaderboard.html" class="header-link">Leaderboard</a>
  </div>
</div>

<div class="hero">
  <h2>API Reference</h2>
  <p>Integrate PolySignal signals into your tools, bots, and dashboards. All public endpoints require no authentication.</p>
</div>

<div class="docs-wrap">

  <div class="info-box">
    <strong>Base URL:</strong> <code>http://localhost:3000</code><br>
    <strong>Rate Limit:</strong> 100 requests/minute per IP<br>
    <strong>Auth:</strong> Public endpoints need no auth. Authenticated endpoints accept session cookies or <code>X-API-Key</code> header.<br>
    <strong>API Key Format:</strong> <code>pk_live_&lt;32 hex chars&gt;</code> — generate via Settings tab or <code>POST /api/keys/generate</code>
  </div>

  <div class="section-title">Health & Status</div>
  <div id="healthEndpoints"></div>

  <div class="section-title">Scanner</div>
  <div id="scannerEndpoints"></div>

  <div class="section-title">Signals</div>
  <div id="signalEndpoints"></div>

  <div class="section-title">Analytics</div>
  <div id="analyticsEndpoints"></div>

  <div class="section-title">Portfolio</div>
  <div id="portfolioEndpoints"></div>

  <div class="section-title">Learning / ML</div>
  <div id="learningEndpoints"></div>

  <div class="section-title">Leaderboard</div>
  <div id="leaderboardEndpoints"></div>

  <div class="section-title">Strategy Simulator</div>
  <div id="simulatorEndpoints"></div>

  <div class="section-title">Authenticated — Auth</div>
  <div id="authEndpoints"></div>

  <div class="section-title">Authenticated — API Keys</div>
  <div id="keyEndpoints"></div>

  <div class="section-title">Authenticated — Webhooks</div>
  <div id="webhookEndpoints"></div>

  <div class="section-title">Authenticated — Email Alerts</div>
  <div id="emailEndpoints"></div>

  <div class="section-title">Signal Intelligence</div>
  <div id="intelligenceEndpoints"></div>

  <div class="section-title">Admin — Webhook Queue</div>
  <div id="webhookQueueEndpoints"></div>

  <div class="section-title">Portfolio Intelligence</div>
  <div id="portfolioIntelEndpoints"></div>

  <div class="section-title">Notification Delivery</div>
  <div id="deliveryEndpoints"></div>

  <div class="section-title">Walk-Forward Validation</div>
  <div id="walkForwardEndpoints"></div>

  <div class="section-title">Checkout & Billing</div>
  <div id="checkoutEndpoints"></div>

  <div class="section-title">Free Trial</div>
  <div id="trialEndpoints"></div>

  <div class="section-title">Referrals</div>
  <div id="referralEndpoints"></div>

  <div class="section-title">Admin — User Management</div>
  <div id="adminUserEndpoints"></div>

  <div class="section-title">Trading Bot</div>
  <div id="tradingEndpoints"></div>

  <div class="section-title">Admin — Performance & Maintenance</div>
  <div id="perfMaintenanceEndpoints"></div>

  <div class="section-title">Observability — Error Logs</div>
  <div id="logsEndpoints"></div>

  <div class="section-title">A/B Experiments</div>
  <div id="experimentEndpoints"></div>

  <div class="section-title">Signal Decay</div>
  <div id="signalDecayEndpoints"></div>

  <div class="section-title">Stress Testing</div>
  <div id="stressTestEndpoints"></div>

  <div class="section-title">Decision Tracker</div>
  <div id="decisionEndpoints"></div>

  <div class="section-title">Hedge Engine</div>
  <div id="hedgeEndpoints"></div>

  <div class="section-title">System Health</div>
  <div id="systemHealthEndpoints"></div>

  <div class="section-title">Parameter Evolution</div>
  <div id="paramEvolutionEndpoints"></div>

  <div class="section-title">Model Ensemble</div>
  <div id="ensembleEndpoints"></div>

  <div class="section-title">Regime Forecaster</div>
  <div id="regimeEndpoints"></div>

  <div class="section-title">Factor Attribution</div>
  <div id="factorEndpoints"></div>

  <div class="section-title">State Snapshots</div>
  <div id="snapshotEndpoints"></div>

  <div class="section-title">Market Microstructure</div>
  <div id="microstructureEndpoints"></div>

  <div class="section-title">Regime-Adaptive Sizing</div>
  <div id="regimeSizingEndpoints"></div>

  <div class="section-title">Signal Replay</div>
  <div id="signalReplayEndpoints"></div>

  <div class="section-title">Execution Timing</div>
  <div id="timingEndpoints"></div>

  <div class="section-title">Liquidation Risk</div>
  <div id="liquidationEndpoints"></div>

  <div class="section-title">Regime Correlations</div>
  <div id="regimeCorrelationEndpoints"></div>

  <div class="section-title">Liquidity Predictor</div>
  <div id="liquidityEndpoints"></div>

  <div class="section-title">Signal Freshness</div>
  <div id="freshnessEndpoints"></div>

  <div class="section-title">Execution Quality</div>
  <div id="execQualityEndpoints"></div>

  <div class="section-title">Portfolio Optimizer</div>
  <div id="portfolioOptEndpoints"></div>

  <div class="section-title">Arbitrage Detection</div>
  <div id="arbitrageEndpoints"></div>

  <div class="section-title">Market Sentiment</div>
  <div id="sentimentEndpoints"></div>

  <div class="section-title">Programmatic API (API Key Required)</div>
  <div id="v1Endpoints"></div>

</div>

<div class="footer">PolySignal &mdash; <a href="/">Back to Dashboard</a></div>

<script>
const ENDPOINTS = {
  healthEndpoints: [
    { method: "GET", path: "/health", desc: "Simple uptime check", tryable: true },
    { method: "GET", path: "/health/detailed", desc: "Per-source health, scanner stats, memory usage", tryable: true }
  ],
  scannerEndpoints: [
    { method: "GET", path: "/api/scanner/state", desc: "All tracked markets with current prices and signals", tryable: true },
    { method: "GET", path: "/api/scanner/signals", desc: "Active trading signals only", tryable: true },
    { method: "GET", path: "/api/scanner/stats", desc: "Scanner statistics (tracked, categories, signal count)", tryable: true },
    { method: "GET", path: "/api/scanner/health", desc: "Per-market health: error counts, success rate, consecutive failures", tryable: true },
    { method: "GET", path: "/api/scanner/rotation?limit=50", desc: "Market rotation log: recently added/removed markets", tryable: true }
  ],
  signalEndpoints: [
    { method: "GET", path: "/api/signals/recent?limit=10", desc: "Recent signals. Supports cursor pagination: add &before=ID to paginate", tryable: true },
    { method: "GET", path: "/api/signals/stats", desc: "Overall win rate, P&L, category/strength breakdown", tryable: true },
    { method: "GET", path: "/api/public-stats?days=30", desc: "Full performance dashboard data for public stats page", tryable: true },
    { method: "GET", path: "/api/signal/:id", desc: "Single signal detail by ID" }
  ],
  analyticsEndpoints: [
    { method: "GET", path: "/api/analytics/timeseries?days=7", desc: "Daily bucketed stats (wins, losses, win rate, P&L)", tryable: true },
    { method: "GET", path: "/api/analytics/calibration", desc: "Confidence score calibration vs actual outcomes", tryable: true },
    { method: "GET", path: "/api/analytics/drawdown", desc: "Max drawdown, consecutive streaks, equity curve", tryable: true },
    { method: "GET", path: "/api/analytics/performance?days=7", desc: "Sharpe ratio, best/worst trade, avg P&L", tryable: true },
    { method: "GET", path: "/api/analytics/market/:marketId", desc: "Per-market performance stats" },
    { method: "GET", path: "/api/analytics/regime?days=30", desc: "Win rate by regime, regime×category matrix, regime×strength breakdown", tryable: true },
    { method: "GET", path: "/api/analytics/export?format=csv&days=30", desc: "Export signals as CSV or JSON (Pro)", tryable: true }
  ],
  portfolioEndpoints: [
    { method: "GET", path: "/api/portfolio/positions", desc: "Open virtual positions", tryable: true },
    { method: "GET", path: "/api/portfolio/summary", desc: "Portfolio KPIs (exposure, P&L, win rate)", tryable: true },
    { method: "GET", path: "/api/portfolio/recent?limit=20", desc: "Recent closed trades", tryable: true }
  ],
  learningEndpoints: [
    { method: "GET", path: "/api/learning/weights", desc: "Current model weights + combo multipliers", tryable: true },
    { method: "GET", path: "/api/learning/features", desc: "Per-feature win rates", tryable: true },
    { method: "GET", path: "/api/learning/combos", desc: "VWAP+RSI combo pair win rates", tryable: true },
    { method: "GET", path: "/api/learning/status", desc: "Learning system status", tryable: true }
  ],
  leaderboardEndpoints: [
    { method: "GET", path: "/api/leaderboard", desc: "Category rankings, top-edge wins, streaks, top markets", tryable: true }
  ],
  simulatorEndpoints: [
    { method: "GET", path: "/api/simulate?minConfidence=60", desc: "Backtest strategy with filters (confidence, edge, category, strength, side)", tryable: true },
    { method: "GET", path: "/api/strategies", desc: "List saved strategies", tryable: true },
    { method: "POST", path: "/api/strategies", desc: "Save strategy. Body: { name, filters, description }" },
    { method: "GET", path: "/api/strategies/:id/backtest", desc: "Backtest a saved strategy by ID" },
    { method: "GET", path: "/api/strategies/compare?a=1&b=2", desc: "Compare two strategies side by side" },
    { method: "DELETE", path: "/api/strategies/:id", desc: "Delete a saved strategy" }
  ],
  authEndpoints: [
    { method: "POST", path: "/api/auth/login", desc: "Send magic link email. Body: { email }" },
    { method: "GET", path: "/auth/verify?token=...", desc: "Verify magic link token, set session cookie" },
    { method: "GET", path: "/api/auth/me", desc: "Current user info (email, plan)" },
    { method: "POST", path: "/api/auth/logout", desc: "Clear session cookie" },
    { method: "GET", path: "/api/plan", desc: "Current user plan (free if not logged in)", tryable: true }
  ],
  keyEndpoints: [
    { method: "POST", path: "/api/keys/generate", desc: "Create API key. Body: { name }. Returns raw key (shown once)" },
    { method: "GET", path: "/api/keys", desc: "List your API keys (masked)" },
    { method: "DELETE", path: "/api/keys/:id", desc: "Revoke an API key" }
  ],
  webhookEndpoints: [
    { method: "POST", path: "/api/webhooks", desc: "Register webhook. Body: { url, name }. URL must be HTTPS" },
    { method: "GET", path: "/api/webhooks", desc: "List your webhooks with success/fail counts" },
    { method: "DELETE", path: "/api/webhooks/:id", desc: "Delete a webhook" }
  ],
  emailEndpoints: [
    { method: "GET", path: "/api/email-prefs", desc: "Get email alert preferences (includes maxAlertsPerHour)" },
    { method: "POST", path: "/api/email-prefs", desc: "Update prefs. Body: { alertsEnabled, minConfidence, categories, maxAlertsPerHour }" },
    { method: "GET", path: "/api/throttle-status", desc: "Per-user notification throttle status (count, queued)" },
    { method: "POST", path: "/api/digest/flush", desc: "Flush queued (throttled) signals for digest" }
  ],
  intelligenceEndpoints: [
    { method: "GET", path: "/api/analytics/edge-audit?days=30", desc: "Edge calibration audit: predicted edge vs actual win rate, bias detection", tryable: true },
    { method: "GET", path: "/api/portfolio/predictions", desc: "Settlement predictions for open positions: win probability, risk, suggestion", tryable: true },
    { method: "GET", path: "/api/learning/drift-status", desc: "Model weight drift detection vs baseline snapshot", tryable: true },
    { method: "POST", path: "/api/learning/drift-baseline", desc: "Reset drift baseline to current weights" }
  ],
  webhookQueueEndpoints: [
    { method: "GET", path: "/api/admin/webhook-queue", desc: "Webhook delivery queue status and recent entries", tryable: true },
    { method: "POST", path: "/api/admin/webhook-queue/replay/:id", desc: "Replay a failed webhook delivery" },
    { method: "POST", path: "/api/admin/webhook-queue/purge?days=7", desc: "Purge old delivered/failed queue entries" }
  ],
  portfolioIntelEndpoints: [
    { method: "GET", path: "/api/portfolio/risk", desc: "Portfolio risk attribution: concentration (HHI), side exposure, max single position, drawdown attribution", tryable: true },
    { method: "GET", path: "/api/portfolio/correlation-matrix?days=30", desc: "Cross-market correlation matrix: pairwise Pearson correlations, clusters, diversity score, correlated pairs", tryable: true },
    { method: "GET", path: "/api/portfolio/open-correlations", desc: "Correlation analysis for currently open positions: correlated pairs, risk level", tryable: true }
  ],
  deliveryEndpoints: [
    { method: "GET", path: "/api/notifications/delivery-audit", desc: "Per-user notification delivery audit log (auth required)" },
    { method: "GET", path: "/api/admin/delivery-stats", desc: "Global delivery health: success/fail/throttle rates over N days", tryable: true }
  ],
  walkForwardEndpoints: [
    { method: "GET", path: "/api/simulate/walk-forward?minConfidence=60", desc: "Walk-forward validation: 70/30 train/test split with overfitting detection (Pro)", tryable: true },
    { method: "GET", path: "/api/signals/by-date?date=2026-02-15", desc: "All signals for a specific date (for equity curve drill-down)", tryable: true }
  ],
  checkoutEndpoints: [
    { method: "POST", path: "/api/checkout/create", desc: "Create Stripe Checkout session. Body: { plan: 'basic'|'pro' }" }
  ],
  trialEndpoints: [
    { method: "POST", path: "/api/trial/start", desc: "Start 7-day Pro trial (one per account, auth required)" },
    { method: "GET", path: "/api/trial/status", desc: "Get trial status: active, daysRemaining, eligible" }
  ],
  referralEndpoints: [
    { method: "GET", path: "/api/referral/code", desc: "Get or create your referral code + stats (auth required)" },
    { method: "POST", path: "/api/referral/claim", desc: "Claim a referral. Body: { code }. Awards referrer after 3 completions" },
    { method: "GET", path: "/api/referral/stats", desc: "Referral stats: completed, rewards earned, next reward progress" }
  ],
  adminUserEndpoints: [
    { method: "GET", path: "/api/admin/subscribers?plan=pro", desc: "List subscribers. Supports cursor: &before=ID. Returns { subscribers, nextCursor, hasMore }", tryable: true },
    { method: "POST", path: "/api/admin/grant-comp", desc: "Grant comp access. Body: { email, plan, days }" },
    { method: "GET", path: "/api/admin/cache-stats", desc: "Response cache hit rate and entry count", tryable: true }
  ],
  tradingEndpoints: [
    { method: "GET", path: "/api/trading/status", desc: "Trading bot status: control state, risk, exposure, monitor, executions", tryable: true },
    { method: "POST", path: "/api/trading/control", desc: "Bot control: { action: stop|pause|resume|drain } (auth required)" },
    { method: "GET", path: "/api/trading/executions?limit=10", desc: "Recent trade executions (live + dry-run) from SQLite", tryable: true },
    { method: "GET", path: "/api/trading/open", desc: "Currently open trade executions", tryable: true },
    { method: "GET", path: "/api/trading/execution/:id", desc: "Get single execution by ID", tryable: false },
    { method: "POST", path: "/api/trading/close/:id", desc: "Cancel a specific open position (auth required)" },
    { method: "POST", path: "/api/trading/liquidate-all", desc: "Cancel all open positions + pause bot (auth required)" },
    { method: "GET", path: "/api/trading/audit?days=7&limit=100", desc: "Query trade audit log with filters", tryable: true },
    { method: "GET", path: "/api/trading/audit/summary?days=7", desc: "Audit event counts by type", tryable: true },
    { method: "GET", path: "/api/trading/audit/execution/:id", desc: "Full audit trail for a specific execution", tryable: false },
    { method: "GET", path: "/api/trading/reconcile", desc: "Position reconciliation — detect stale/orphaned positions (auth required)" },
    { method: "GET", path: "/api/trading/pnl", desc: "Real-time unrealized P&L for all open positions", tryable: true },
    { method: "GET", path: "/api/trading/config", desc: "Current trading config values with metadata", tryable: true },
    { method: "POST", path: "/api/trading/config", desc: "Update trading config: { max_bet_usd, daily_loss_limit_usd, ... } (auth required)" },
    { method: "GET", path: "/api/trading/analytics", desc: "Trade performance: win rate, P&L by category/day, edge accuracy, close reasons", tryable: true },
    { method: "POST", path: "/api/trading/reconcile/repair", desc: "Auto-repair stale positions older than maxAgeHours (default 72h, auth required)" },
    { method: "GET", path: "/api/trading/hourly-stats", desc: "Win rates grouped by hour-of-day (0-23 UTC) with sample sizes", tryable: true },
    { method: "GET", path: "/api/trading/filter-stats", desc: "Signal filter funnel: how many signals blocked by each gate (dedup, cooldown, regime, quality, etc)", tryable: true },
    { method: "GET", path: "/api/trading/quality-stats", desc: "Quality score distribution across recent trade executions", tryable: true },
    { method: "GET", path: "/api/trading/daily-summary?date=2026-02-15", desc: "Daily trade summary: P&L, win rate, quality stats, regime/category/side breakdown", tryable: true },
    { method: "GET", path: "/api/trading/export?days=30&format=json", desc: "Export trade executions with full decision context (quality, regime, streak, sizing). Use format=csv for CSV", tryable: true },
    { method: "GET", path: "/api/trading/calibration", desc: "Confidence calibration: actual vs expected win rate per confidence decile, flags miscalibrated buckets", tryable: true },
    { method: "GET", path: "/api/trading/attribution?days=30", desc: "P&L attribution: performance breakdown by quality tier, regime, category, hour, sizing method, strength", tryable: true },
    { method: "GET", path: "/api/trading/regime-history", desc: "Regime transition tracker: current regime distribution and per-market transition history with stability", tryable: true },
    { method: "GET", path: "/api/trading/category-weights", desc: "Per-category learned indicator weights, global model version, combo multipliers, and category tuning parameters", tryable: true },
    { method: "GET", path: "/api/trading/slippage?days=30", desc: "Slippage analysis: overall avg, breakdown by size bucket, category, and hour-of-day", tryable: true },
    { method: "GET", path: "/api/trading/anomalies", desc: "Rolling performance anomaly detection: compares recent 20 trades vs 100-trade baseline for win rate, Sharpe, P&L degradation", tryable: true },
    { method: "GET", path: "/api/trading/execution-quality?days=30", desc: "Execution quality metrics: latency stats (avg/p50/p95/p99), fill rates, quality score (0-100), breakdown by hour and size", tryable: true }
  ],
  perfMaintenanceEndpoints: [
    { method: "GET", path: "/api/admin/perf", desc: "Per-route response times, error rates, slow request log", tryable: true },
    { method: "POST", path: "/api/admin/perf/reset", desc: "Reset performance counters (auth required)" },
    { method: "GET", path: "/api/admin/maintenance", desc: "Last maintenance run status, next scheduled", tryable: true },
    { method: "POST", path: "/api/admin/maintenance/run", desc: "Manually trigger maintenance (void stale, purge old, ANALYZE)" }
  ],
  logsEndpoints: [
    { method: "GET", path: "/api/logs?source=binance&days=7", desc: "Query structured error logs with filters", tryable: true },
    { method: "GET", path: "/api/logs/trends?days=7", desc: "Error trends by source and level", tryable: true }
  ],
  experimentEndpoints: [
    { method: "GET", path: "/api/experiments", desc: "List all A/B experiments with status, sample count, and winner", tryable: true },
    { method: "GET", path: "/api/experiments/:id", desc: "Detailed experiment stats: per-arm win rates, P&L, Thompson sampling probability of being best" },
    { method: "POST", path: "/api/experiments", desc: "Create experiment. Body: { name, arms: ['control', 'variant_a'] } (auth required)" },
    { method: "POST", path: "/api/experiments/:id/promote", desc: "Manually promote a winner. Body: { arm } (auth required)" }
  ],
  signalDecayEndpoints: [
    { method: "GET", path: "/api/signals/decay-curves", desc: "Signal decay curves by indicator category (fast/medium/slow): half-lives, expected multiplier at various hold durations", tryable: true }
  ],
  stressTestEndpoints: [
    { method: "GET", path: "/api/portfolio/stress-test", desc: "Run stress test on open positions: BTC crash, vol spike, political shock, correlated sell-off scenarios with per-position impact", tryable: true },
    { method: "GET", path: "/api/portfolio/tail-risk?days=90", desc: "Tail risk metrics: 95th/99th percentile daily loss, max drawdown, daily Sharpe, volatility from historical trades", tryable: true }
  ],
  decisionEndpoints: [
    { method: "GET", path: "/api/trading/decisions?limit=50", desc: "Recent decision log: which gates passed/blocked for each signal, scores, near misses", tryable: true },
    { method: "GET", path: "/api/trading/near-misses?days=7", desc: "Signals that passed all filters except one — reveals overly tight gates", tryable: true },
    { method: "GET", path: "/api/trading/filter-cost?days=7", desc: "Filter cost analysis: how many signals each gate blocks, pass rate, blocking percentage by gate", tryable: true }
  ],
  hedgeEndpoints: [
    { method: "GET", path: "/api/portfolio/hedge", desc: "Hedge recommendations: side rebalance, category diversification, directional hedges with priority and sizing", tryable: true },
    { method: "GET", path: "/api/portfolio/category-exposure", desc: "Category exposure breakdown: per-category position count, USD exposure, YES/NO split, imbalances", tryable: true },
    { method: "GET", path: "/api/portfolio/beta?days=30", desc: "Portfolio beta by category: how much portfolio P&L co-moves with each category's returns", tryable: true }
  ],
  systemHealthEndpoints: [
    { method: "GET", path: "/api/system/health", desc: "Composite health score (0-100) with per-component breakdown: memory, errors, executions, freshness, database", tryable: true },
    { method: "GET", path: "/api/system/health/alerts", desc: "Active health alerts with severity level (healthy/degraded/unhealthy/critical)", tryable: true },
    { method: "GET", path: "/api/system/health/trend?hours=24", desc: "Health score trend over time from persisted snapshots", tryable: true },
    { method: "GET", path: "/api/system/health/history?limit=50", desc: "In-memory health history ring buffer (5-min intervals)", tryable: true },
    { method: "GET", path: "/api/system/recovery-log?limit=50", desc: "Auto-recovery action log: maintenance runs, cache clears, trading pauses triggered by health drops", tryable: true }
  ],
  paramEvolutionEndpoints: [
    { method: "GET", path: "/api/trading/evolution", desc: "Parameter evolution status: generation, population size, best-ever params and fitness", tryable: true },
    { method: "GET", path: "/api/trading/evolution/best", desc: "Current best evolved parameter set (confidence, edge, sizing, quality gate)", tryable: true },
    { method: "POST", path: "/api/trading/evolution/evolve", desc: "Manually trigger one generation of parameter evolution (auth required)" }
  ],
  ensembleEndpoints: [
    { method: "GET", path: "/api/models/ensemble/weights", desc: "Current ensemble model weights: momentum, mean-reversion, orderbook, macro — with accuracy and prediction counts", tryable: true },
    { method: "GET", path: "/api/models/ensemble/performance", desc: "Per-model accuracy, weight, and prediction count for all ensemble models", tryable: true }
  ],
  regimeEndpoints: [
    { method: "GET", path: "/api/regime/forecast", desc: "Markov chain regime forecast: predicted next regime with confidence, transition probabilities, hour/day bias", tryable: true },
    { method: "GET", path: "/api/regime/transition-matrix", desc: "Full regime transition probability matrix (TREND_UP, TREND_DOWN, RANGE, CHOP)", tryable: true },
    { method: "GET", path: "/api/regime/durations?days=30", desc: "Regime duration distribution from historical signal data", tryable: true }
  ],
  factorEndpoints: [
    { method: "GET", path: "/api/analytics/factor-importance?days=30", desc: "Factor importance ranking: Pearson correlation for numeric factors, information gain for categorical factors, with win/loss breakdowns", tryable: true },
    { method: "GET", path: "/api/analytics/winning-profile?days=30", desc: "Winning trade factor profile: avg quality, confidence, edge, and bet size for wins vs losses", tryable: true }
  ],
  snapshotEndpoints: [
    { method: "GET", path: "/api/system/snapshots?limit=50", desc: "State snapshot history: periodic captures of open positions, risk state, bot state, learning version", tryable: true },
    { method: "GET", path: "/api/system/snapshot/latest", desc: "Latest state snapshot with full detail for crash recovery", tryable: true },
    { method: "POST", path: "/api/system/snapshot", desc: "Manually take a state snapshot (auth required)" }
  ],
  microstructureEndpoints: [
    { method: "GET", path: "/api/analytics/microstructure", desc: "Market microstructure analysis: spread stability, depth persistence, toxic flow detection, liquidity scores for all tracked markets", tryable: true }
  ],
  regimeSizingEndpoints: [
    { method: "GET", path: "/api/trading/regime-sizing", desc: "Regime-adaptive sizing profile: regime multipliers, hour-of-day adjustments, and limit ranges", tryable: true },
    { method: "GET", path: "/api/trading/regime-sizing/current?regime=RANGE", desc: "Current sizing multiplier for a given regime, hour, beta, correlation load, and ensemble agreement", tryable: true }
  ],
  signalReplayEndpoints: [
    { method: "GET", path: "/api/analytics/signal-replay?days=30", desc: "Replay historical signals with alternate parameters: supports minConfidence, minEdge, minQuality, regimes overrides", tryable: true },
    { method: "GET", path: "/api/analytics/strategy-compare?days=30", desc: "Compare 4 strategy configurations (current, aggressive, conservative, trend-only) side by side with simulated P&L", tryable: true }
  ],
  timingEndpoints: [
    { method: "GET", path: "/api/analytics/timing?days=30", desc: "Full timing analysis: hourly, daily, and regime×hour win rate breakdowns with baseline comparison", tryable: true },
    { method: "GET", path: "/api/analytics/timing/windows?days=30", desc: "Optimal trading windows: hot (high win rate) and cold (low win rate) time slots with statistical significance", tryable: true },
    { method: "GET", path: "/api/analytics/timing/recommendation?hour=14&dow=3&regime=RANGE", desc: "Real-time timing recommendation: trade/aggressive/cautious/avoid based on current hour, day, and regime", tryable: true }
  ],
  liquidationEndpoints: [
    { method: "GET", path: "/api/portfolio/liquidation-risk", desc: "Monte Carlo liquidation risk forecast: 500 simulated paths computing breach probability at 4h/8h/24h horizons with position trim recommendations", tryable: true },
    { method: "GET", path: "/api/portfolio/breach-probability?hours=4", desc: "Quick breach probability for a single time horizon", tryable: true }
  ],
  regimeCorrelationEndpoints: [
    { method: "GET", path: "/api/analytics/regime-correlations?days=30", desc: "Cross-category regime correlations: pairwise Pearson correlation of win rates across regimes, divergence detection", tryable: true },
    { method: "GET", path: "/api/analytics/regime-divergence?days=14", desc: "Regime divergence alerts: categories behaving opposite to regime expectations with severity and deviation scores", tryable: true },
    { method: "GET", path: "/api/analytics/category-regime-map?days=30", desc: "Category regime map: best-performing regime per category with win rate breakdown", tryable: true }
  ],
  liquidityEndpoints: [
    { method: "GET", path: "/api/scanner/liquidity-rankings", desc: "Market liquidity rankings: predicted tradability scores based on volume, spread, depth, category, settlement proximity", tryable: true },
    { method: "GET", path: "/api/scanner/liquidity-forecast", desc: "Liquidity forecast with at-risk markets and trading opportunities identified by predicted future liquidity", tryable: true }
  ],
  freshnessEndpoints: [
    { method: "GET", path: "/api/signals/freshness-profile", desc: "Signal freshness profile: category-specific half-lives, regime decay multipliers, decay curves, and staleness thresholds", tryable: true }
  ],
  execQualityEndpoints: [
    { method: "GET", path: "/api/trading/implementation-shortfall?days=30", desc: "Implementation shortfall analysis: slippage decomposition into spread cost, market impact, and timing cost with per-regime breakdowns", tryable: true },
    { method: "GET", path: "/api/trading/counterfactual?days=14", desc: "Counterfactual timing analysis: simulates alternate entry points (-5 to +5 min) to estimate optimal execution timing", tryable: true },
    { method: "GET", path: "/api/trading/factor-pnl?days=30", desc: "Factor P&L attribution: decomposes returns by regime, category, side, confidence quartile, quality, and edge to identify top contributors and detractors", tryable: true }
  ],
  portfolioOptEndpoints: [
    { method: "GET", path: "/api/portfolio/optimize", desc: "Portfolio optimization: current vs target allocation, category concentration limits, directional bias check, constraint violations, and rebalance actions", tryable: true },
    { method: "GET", path: "/api/portfolio/rebalance-schedule", desc: "Rebalancing schedule: time-based, drift-based, and violation-based triggers with last rebalance timestamp", tryable: true },
    { method: "GET", path: "/api/portfolio/efficient-frontier?days=30", desc: "Efficient frontier approximation: risk/return tradeoffs at various concentration levels with per-category Sharpe ratios", tryable: true }
  ],
  arbitrageEndpoints: [
    { method: "GET", path: "/api/analytics/arbitrage", desc: "Arbitrage scanner: detects complementary mismatches (YES+NO != $1), category outliers (z-score > 2), and cross-market divergences with edge estimates", tryable: true },
    { method: "GET", path: "/api/analytics/arbitrage/heatmap", desc: "Arbitrage heatmap: per-category mispricing scores showing where the most exploitable discrepancies exist", tryable: true }
  ],
  sentimentEndpoints: [
    { method: "GET", path: "/api/analytics/sentiment", desc: "Market sentiment: aggregate bullish/bearish/neutral scores (-100 to +100) derived from price momentum, volume, spreads, orderbook imbalance, and volatility", tryable: true },
    { method: "GET", path: "/api/analytics/sentiment/momentum", desc: "Sentiment momentum: detects directional shifts in market sentiment with magnitude and category breakdown", tryable: true }
  ],
  v1Endpoints: [
    { method: "GET", path: "/api/v1/signals", desc: "Recent signals. Supports &before=ID cursor (requires X-API-Key header)" },
    { method: "GET", path: "/api/v1/stats", desc: "Signal statistics (requires X-API-Key header)" },
    { method: "GET", path: "/api/v1/scanner", desc: "Active signals + scanner stats (requires X-API-Key header)" }
  ]
};

function renderEndpoints() {
  for (const [sectionId, eps] of Object.entries(ENDPOINTS)) {
    const el = document.getElementById(sectionId);
    if (!el) continue;
    el.innerHTML = eps.map((ep, i) => {
      const mc = ep.method.toLowerCase();
      const tryBtn = ep.tryable ? `<div class="ep-actions"><button class="try-btn" onclick="tryEndpoint('${sectionId}_${i}','${ep.path}')">Try it</button></div>` : "";
      return `<div class="endpoint">
        <div class="ep-header">
          <span class="ep-method ${mc}">${ep.method}</span>
          <span class="ep-path">${esc(ep.path)}</span>
        </div>
        <div class="ep-desc">${esc(ep.desc)}</div>
        ${tryBtn}
        <pre class="ep-response" id="resp_${sectionId}_${i}"></pre>
      </div>`;
    }).join("");
  }
}

async function tryEndpoint(id, path) {
  const el = document.getElementById("resp_" + id);
  if (!el) return;
  el.style.display = "block";
  el.textContent = "Loading...";
  try {
    const res = await fetch(path);
    const data = await res.json();
    el.textContent = JSON.stringify(data, null, 2);
  } catch (err) {
    el.textContent = "Error: " + err.message;
  }
}

function esc(s) { if (!s) return ""; const el = document.createElement("span"); el.textContent = s; return el.innerHTML; }

renderEndpoints();
</script>
</body>
</html>
